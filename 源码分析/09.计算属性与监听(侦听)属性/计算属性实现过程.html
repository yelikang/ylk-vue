<!--
 * @Description: 
 * @Autor: lizi
 * @Date: 2022-04-26 14:38:45
 * @LastEditors: lizi
 * @LastEditTime: 2022-06-13 23:36:05
 * @FilePath: \ylk-vue\源码分析\09.计算属性与监听(侦听)属性\计算属性实现过程.html
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>computed计算属性实现过程</title>
  </head>
  <body>
    <div id="app">
      <button @click="change(1)">变更姓名</button>
      <button @click="change(2)">变更年龄</button>
      <!-- 
        理论上页面上没有调用msg属性时，msg属性的变更不会导致c_info的更新，因为页面的render函数不会重新调用
        但是在computed 计算属性中有下面一段代码
        if (Dep.target) {
          watcher.depend()
        }
        计算属性c_info中的依赖属性msg会强制收集 computed watcher的上级渲染watcher；当msg变换时，会重新渲染，从而再次调用c_info
      -->
      <!-- <div>{{msg}}</div> -->
      <div>{{c_info}}</div>
    </div>
  </body>
  <script src="../../dist/vue.js"></script>
  <script>
    new Vue({
      el: "#app",
      data: {
        age: 12,
        msg: "小红",
      },
      methods: {
        change(type) {
          switch (type) {
            case 1:
              this.msg = "小红人";
              break;
            case 2:
              this.age = 20;
              break;
            default:
              break;
          }
        },
      },
      computed: {
        // 1.查看computed初始化过程
        // defineComputed 对computed计算属性的key进行代理劫持，读取计算属性，实际会调用computedGetter

        // 2.computed依赖收集过程(里面依赖的属性会订阅当前创建的computed watcher,Dep.target)
        // 3.computed缓存、更新调用过程

        // 读取计算属性的时候，会调用watcher的evaluate，执行wather的get方法，get中pushTarget将当前computed watch激活为Dep.target
        // 这个时候执行computed属性对应的function，如果读取其它属性，其它属性的dep消息中心就会搜集computed watcher的依赖
        // 当其它属性变更时也会通知computed wather去update，将dirty设置为true，再次读取计算属性时调用computedGetter，发现dirty变为true，从而再次执行evaluate
        c_info() {
          return this.msg + this.age;
        },
      },
    });
  </script>
</html>
