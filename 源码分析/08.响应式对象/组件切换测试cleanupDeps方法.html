<!--
 * @Description: 
 * @Autor: lizi
 * @Date: 2022-04-26 14:38:45
 * @LastEditors: lizi
 * @LastEditTime: 2022-05-23 15:17:10
 * @FilePath: \ylk-vue\源码分析\08.响应式对象\组件切换测试cleanupDeps方法.html
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cleanupDeps方法测试</title>
  </head>
  <body>
    <div id="app">
      <button @click="toggle">切换</button>
      <button @click="change">变更</button>

      <div v-if="show"> 
        {{msg}}
      </div>
      <div v-else>
        {{msg1}}
      </div>
    
    </div>
  </body>
  <script src="../../dist/vue.js"></script>
  <script>
    new Vue({
      el: "#app",
      data: {
        show: true,
        msg:'小红',
        msg1:'小明'
      },
      methods: {
        toggle(){
          // 这里切换之后，组件会重新updateComponent，然后调用_render重新调用getter
          // getter中会重新进行dep.depend调用Watcher中的addDep，对用到的属性的dep进行收集(某个属性没有调用就不会收集)
          // updateComponent完之后，对比之前的depIds与新的newDepIds，发现某些属性没有进行依赖收集(没有调用getter)
          // 就从该属性的dep消息中心中移除掉Watcher订阅者，当属性变更调用setter的时候，发现dep消息中心没有Watcher，就不会进行组件更新
          // 例如当下面的change改变msg时，调用setter，发现该属性没有对应的Watcher订阅者，不会调用Watcher的update；也就不再调用updateComponent进行更新
          this.show =  false;
        },
        change(){
          this.msg = '小红' + new Date().getTime();
          this.$nextTick().then(res=>{
            console.log(6)
          })
        }
      },
      watch:{
        msg(oldVal, newVal){
          console.log('xxx')
        }
      }
    });
  </script>
</html>
